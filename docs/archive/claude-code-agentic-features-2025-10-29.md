# Claude Code: Agentic Features and Best Practices

## Overview of Claude Code’s Agentic Environment

Claude Code is Anthropic’s agentic coding assistant that runs in your terminal. It doesn’t just chat – it **reads your project code, edits files, runs shell commands, and creates commits under your guidance**[\[1\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=,let%20you%20scale%20reliable%2C%20repeatable). Think of the **main Claude agent** as a collaborative coder that can take actions in your development workflow. It maintains awareness of your entire codebase and even can pull in external data via Anthropic’s Model Context Protocol (MCP) connectors (for example, to access Google Drive, Figma, Slack, etc.)[\[2\]](https://docs.claude.com/en/docs/claude-code/overview#:~:text=will%20analyze%20your%20codebase%2C%20identify,Google%20Drive%2C%20Figma%2C%20and%20Slack). The main agent works with a suite of features – **persistent memory**, **slash commands**, **subagents**, and **skills** – to help you build and automate complex coding tasks.

**Subagents** in Claude Code are specialized “mini-agents” you can define with their own system prompt, tool permissions, and **independent context windows**[\[3\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=chat.%20,let%20you%20scale%20reliable%2C%20repeatable)[\[4\]](https://docs.claude.com/en/docs/claude-code/sub-agents#:~:text=Subagents%20are%20pre,Each%20subagent). The main agent can delegate specific tasks to these subagents (for example, a code-reviewer, test-runner, or debugger agent) and each subagent will work *in isolation from the main conversation*, then return the result[\[5\]](https://docs.claude.com/en/docs/claude-code/sub-agents#:~:text=Each%20subagent%20operates%20in%20its,level%20objectives). This isolation means a subagent won’t pollute the main agent’s context – e.g. a review agent will not make the main agent forget high-level goals[\[6\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=prompt%2C%20tool%20permissions%2C%20and%20an,you%20scale%20reliable%2C%20repeatable%20workflows). Subagents thus enable more scalable and reliable workflows by handling detail-heavy subtasks with a focused context and expertise area[\[7\]](https://docs.claude.com/en/docs/claude-code/sub-agents#:~:text=Specialized%20expertise). You can create subagents on a per-project or user-global basis, and share them with your team via source control just like code[\[8\]](https://docs.claude.com/en/docs/claude-code/sub-agents#:~:text=Reusability).

In summary, Claude Code’s architecture consists of a primary agent enhanced by optional subagents and structured extensibility mechanisms (commands and skills). This design embraces a “Unix philosophy” of composability – Claude Code can be scripted and composed in pipelines (even used in CI, or chained with shell commands via claude \-p CLI)[\[9\]](https://docs.claude.com/en/docs/claude-code/overview#:~:text=commits,in). Below we break down each key component and how to leverage them in **workflows that combine slash commands, subagents, and skills** for advanced coding automation.

## Persistent Memory with *CLAUDE.md* and File Imports (@)

Claude Code persists context across sessions using special Markdown files (commonly named **CLAUDE.md**) that serve as long-term memory and project configuration. These memory files let you provide **project-wide or user-wide instructions** (coding style guides, architectural notes, etc.) that are automatically loaded into Claude’s context on startup[\[10\]](https://docs.claude.com/en/docs/claude-code/memory#:~:text=members%20via%20source%20control%20User,more%20specific%20memories%20build%20upon). Claude Code supports a hierarchy of memory scopes[\[11\]](https://docs.claude.com/en/docs/claude-code/memory#:~:text=Linux%3A%20%60%2Fetc%2Fclaude,all%20projects):

* **Enterprise-level CLAUDE.md** (centrally managed by an org’s IT for company-wide standards) – highest level.

* **Project-level CLAUDE.md** (checked into your repo, e.g. at the project root or in a .claude/ folder) – shared with your team for that project.

* **User-level CLAUDE.md** (\~/.claude/CLAUDE.md in your home dir) – your personal default preferences applied to all projects.

* *(Deprecated: CLAUDE.local.md)* – older mechanism for local overrides, now superseded by import includes.

All applicable memory files are loaded together when you launch Claude Code, with higher-level files providing a foundation that more specific files can build upon[\[11\]](https://docs.claude.com/en/docs/claude-code/memory#:~:text=Linux%3A%20%60%2Fetc%2Fclaude,all%20projects). The contents of CLAUDE.md should be structured and clear. A recommended practice is to use bullet points and headings to organize instructions (group related guidelines under headings) and **be as specific as possible** (e.g. “Use 2-space indentation for YAML files” instead of “format properly”)[\[12\]](https://docs.claude.com/en/docs/claude-code/memory#:~:text=%2A%20Be%20specific%3A%20%E2%80%9CUse%202,to%20date%20information%20and%20context). Periodically review and update these memories as the project evolves, so Claude is always operating with up-to-date info[\[13\]](https://docs.claude.com/en/docs/claude-code/memory#:~:text=,to%20date%20information%20and%20context).

**Including external files in memory:** CLAUDE.md supports an **@import syntax** to pull in content from other files. For example, your project CLAUDE.md might say: *“See @README for project overview and @package.json for available npm commands”*[\[14\]](https://docs.claude.com/en/docs/claude-code/memory#:~:text=CLAUDE,following%20example%20imports%203%20files). At runtime, Claude will import the contents of those files into the context. You can even reference specific Markdown docs (e.g. architectural decisions) or personal notes. Both relative paths (within the repo) and absolute paths are allowed[\[15\]](https://docs.claude.com/en/docs/claude-code/memory#:~:text=See%20%40README%20for%20project%20overview,npm%20commands%20for%20this%20project). This means you can modularize your memory – e.g. keep large policy docs separate and just include them. It replaces the old approach of maintaining a CLAUDE.local.md per user: now each team member can host personal instructions in a file (say \~/.claude/my-project-instructions.md) and the project CLAUDE.md can import it via a path like @\~/.claude/my-project-instructions.md[\[16\]](https://docs.claude.com/en/docs/claude-code/memory#:~:text=Copy). This avoids committing personal prefs to git while still letting each user extend the project memory.

To quickly **add or edit memory entries**, Claude Code provides shortcuts. Simply starting a message with \# lets you append a note to CLAUDE.md on the fly (e.g. \# Always create unit tests for new endpoints. will be added to memory)[\[17\]](https://docs.claude.com/en/docs/claude-code/memory#:~:text=Quickly%20add%20memories%20with%20the,shortcut). The /memory slash command opens an editor for the loaded memory files, so you can make structured updates in place[\[18\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=,for%20safer%2C%20more%20autonomous%20execution). Also, running /init in a new project triggers Claude to analyze the codebase and auto-generate an initial CLAUDE.md (a starter template of insights about the project structure)[\[19\]](https://github.com/centminmod/my-claude-code-setup#:~:text=3,YouTube%20guides%20here%20and%20here). You can then refine this with project conventions (coding standards, tech stack info, glossary of terms, etc.)[\[20\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=,as%20of%20June%2018%2C%202025)[\[21\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=2,your%20standards).

**How Claude uses memory:** When conversing or coding, Claude will draw upon the CLAUDE.md content as additional system context. For example, if your memory says “We use PSR-12 style in PHP,” Claude will follow that in formatting any PHP code it writes. The memory can also contain high-level **project plans or notes**, which Claude can factor into its reasoning. If multiple CLAUDE.md files are present at different directory levels, Claude will load them hierarchically (it searches upward from your current folder, including any CLAUDE.md it finds)[\[22\]](https://docs.claude.com/en/docs/claude-code/memory#:~:text=How%20Claude%20looks%20up%20memories). It also dynamically loads memory for subdirectories if you start working in a nested part of the repo – so you could have module-specific CLAUDE.md files that only load when relevant, keeping context more focused[\[22\]](https://docs.claude.com/en/docs/claude-code/memory#:~:text=How%20Claude%20looks%20up%20memories).

Overall, curating your CLAUDE.md is key to **context engineering**: it’s how you give Claude persistent knowledge and steer its behavior. Keep it **concise, structured, and relevant**, and use the @file includes to avoid bloating the main file with too much text. By maintaining a good memory bank (and updating it via code review summaries, changelogs, etc.), you ensure Claude always has the important project context at hand.

## Custom Slash Commands and the Slash-Command Tool

Claude Code provides **slash commands** – special commands you can trigger by typing a forward slash – to control its behavior and execute preset tasks. Many **built-in commands** exist (for example, /help, /clear, /init, /commit, /agents, etc.) for managing sessions and common actions[\[23\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=Command%20Purpose%20%60%2Fadd,specific%20details)[\[18\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=,for%20safer%2C%20more%20autonomous%20execution). More powerfully, you can **define your own slash commands** (custom commands) as reusable prompt templates stored in Markdown files. This is extremely useful for **frequently-used prompts or multi-step instructions** that you don’t want to rewrite each time.

A custom slash command is simply a markdown file (ending in .md) placed in either the **project’s** .claude/commands/ directory or your **personal** \~/.claude/commands/ directory. Claude Code automatically discovers these and makes them available via the / menu[\[24\]](https://www.anthropic.com/engineering/claude-code-best-practices#:~:text=c). For example, if you create .claude/commands/**fix-github-issue.md** with content like:

Please analyze and fix the GitHub issue: $ARGUMENTS.

Follow these steps:  
1\. Use \`gh issue view\` to get the issue details.  
2\. Understand the problem described.  
3\. Search the codebase for relevant files.  
4\. Implement the necessary changes to fix the issue.  
5\. Run tests to verify the fix.  
6\. Ensure code passes linting and type checking.  
7\. Commit with a descriptive message and open a PR.

…then Claude Code will expose a command **/project:fix-github-issue**. You could invoke it by typing /project:fix-github-issue 1234 to fix issue \#1234, and Claude will execute the multi-step plan defined in the file[\[25\]](https://www.anthropic.com/engineering/claude-code-best-practices#:~:text=For%20example%2C%20here%E2%80%99s%20a%20slash,and%20fix%20a%20Github%20issue)[\[26\]](https://www.anthropic.com/engineering/claude-code-best-practices#:~:text=Copy). Custom commands support **arguments**: in templates, you can use placeholders like $ARGUMENTS (for all arguments as a single string) or $1, $2, etc. for positional args[\[27\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=Pass%20dynamic%20values%20to%20commands,using%20argument%20placeholders)[\[28\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=,etc). In the above example, $ARGUMENTS would be replaced with “1234” (the issue number) at runtime[\[25\]](https://www.anthropic.com/engineering/claude-code-best-practices#:~:text=For%20example%2C%20here%E2%80%99s%20a%20slash,and%20fix%20a%20Github%20issue). This makes commands flexible – e.g. a /review-pr $1 command could take a PR number and run a standard review routine on it.

Commands are **namespaced** by directory. For instance, a file at .claude/commands/frontend/component.md results in a /project:component command labeled as “(project:frontend)” in the help menu[\[29\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=Namespacing). This helps organize commands by domain without cluttering their invocation names. Project-level commands show with a “(project)” tag and are shared with your team via git, while personal commands show as “(user)” and are only for you[\[30\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=Project%20commands)[\[31\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=Personal%20commands).

Once you start having many custom commands, a challenge is giving the AI access to them. Claude Code addresses this via the **SlashCommand tool**, an internal mechanism that surfaces custom command metadata to Claude’s reasoning. When this tool is enabled, Claude can see the list of available custom commands (up to a certain token budget) and even **decide to invoke them autonomously** when it judges appropriate. Essentially, slash commands become part of Claude’s “toolbox.” For safety, by default *only user-defined commands with a description in their frontmatter* are exposed – built-in commands like /logout or /init are **not** model-invokable via the tool[\[32\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=,slash%20commands%20that). If you want to hide a specific custom command from Claude’s autonomous use, you can mark it with disable-model-invocation: true in its YAML frontmatter, or disable the SlashCommand tool entirely via the /permissions interface[\[33\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=Disable%20)[\[34\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=Disable%20specific%20commands%20only). In practice, this means you should **always add a description field** to your custom command’s top matter explaining its purpose; Claude will use that to decide when to apply it. The platform imposes a character budget (by default 15k characters total) for all command descriptions given to the model[\[35\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=The%20,command%E2%80%99s%20name%2C%20args%2C%20and%20description) – if you have a very large number of commands, only the most relevant will be shown to Claude, to conserve context.

**Why use slash commands?** They are the fundamental **composable units** of Claude Code’s behavior. Each command is like a mini-script or macro. Instead of repeatedly prompting “Explain this code” or “Optimize this function” with lengthy instructions, you can wrap the prompt in a command like /explain or /optimize for one-shot reuse[\[36\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=Use%20slash%20commands%20for)[\[37\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=,this%20code%20for%20performance%20issues%E2%80%9D). This not only saves time but ensures consistency (everyone on your team uses the same review checklist, for example). Slash commands are explicitly invoked by you (or by Claude via the tool, if allowed), so you maintain control over *when* they run. They are best for **quick, focused tasks or templates** that fit in one file[\[38\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=Quick%2C%20frequently)[\[39\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=Use%20Skills%20for). In fact, an official docs breakdown suggests using slash commands for things like simple code review or explanation snippets, whereas more complex, multi-step workflows are better suited to Skills (discussed next)[\[36\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=Use%20slash%20commands%20for)[\[40\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=Use%20Skills%20for).

Finally, note that slash commands can incorporate tool usage and special modes. Within a command’s text, you can instruct Claude to run shell commands, use MCP connectors, or even switch to “extended thinking mode.” For example, including the word *“think harder”* in a command prompt triggers Claude’s **ultra-thinking mode** (allocating more reasoning time)[\[41\]](https://www.anthropic.com/engineering/claude-code-best-practices#:~:text=early%20on%20in%20a%20conversation,reset%20to%20this%20spot%20if). You could create a /deep-analyze command that says “think harder” about a problem before proceeding, to systematically force Claude into a more thorough reasoning process. The flexibility of Markdown means you can craft very sophisticated commands that guide Claude through a series of actions with proper reasoning breaks.

## Agent Skills: Extend Claude with Autonomous Expertise

Agent **Skills** are a newer Claude Code feature that lets you package up domain-specific expertise or workflows into modular units that Claude can use **autonomously**. A Skill is essentially a folder containing a SKILL.md (with instructions/knowledge) and any number of supporting files (scripts, reference docs, templates, etc.)[\[42\]](https://docs.claude.com/en/docs/claude-code/skills#:~:text=Agent%20Skills%20package%20expertise%20into,to%20trigger%20them%29.%20Benefits)[\[43\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=Aspect%20Slash%20Commands%20Agent%20Skills,Sharing%20Via%20git%20Via%20git). Once a Skill is installed, **Claude’s model will automatically decide when to invoke it** based on its relevance to the user’s request[\[44\]](https://docs.claude.com/en/docs/claude-code/skills#:~:text=consists%20of%20a%20,to%20trigger%20them%29.%20Benefits). This contrasts with slash commands, which are only triggered when explicitly invoked by name[\[45\]](https://docs.claude.com/en/docs/claude-code/skills#:~:text=invoked%3A%20Skills%20are%20model,to%20trigger%20them%29.%20Benefits). Think of Skills as **background plugins or knowledge packs**: they extend Claude’s capabilities or give it new “skills” that it can draw upon without being told to.

Some examples of Skills might be: a “PDF Processor” skill that knows how to parse and fill PDF forms (with a Python script included), or a “Code Review” skill that contains a detailed checklist and style guide spread across multiple files[\[40\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=Use%20Skills%20for)[\[46\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=,with%20style%20guides%20and%20templates). For instance, instead of a simple /review command, you could have a **Code Review skill** that has extensive guidance: a SKILL.md describing the overall review process, plus separate files like SECURITY.md for security checks, PERFORMANCE.md for performance tips, STYLE.md for style rules, and maybe some scripts to run static analyzers[\[47\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=Example%20comparison)[\[48\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=.claude%2Fskills%2Fcode,linters.sh). When you ask Claude “Can you review this code?”, it can detect that the Code Review skill is relevant and automatically load those resources to perform a thorough review[\[49\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=Usage%3A%20,a%20Skill)[\[50\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=Usage%3A%20%E2%80%9CCan%20you%20review%20this,scripts%2C%20and%20organized%20reference%20material).

**Creating and using Skills:** Skills are stored either globally in \~/.claude/skills/ (personal skills available in all projects) or in a project’s .claude/skills/ directory (shared with your team via git)[\[51\]](https://docs.claude.com/en/docs/claude-code/skills#:~:text=Personal%20Skills)[\[52\]](https://docs.claude.com/en/docs/claude-code/skills#:~:text=Project%20Skills). Each Skill gets its own subfolder. In that folder, the mandatory file is SKILL.md which describes what the skill does and provides the core instructions for Claude. You can include any other files your skill needs – for example, configuration files, code templates, or data files. After creating or adding a skill, Claude Code will automatically load it on startup (and you can see installed skills via the /help or possibly a /skills list command). When you prompt Claude, **the model itself decides** if any skill should be applied; it matches your query against the skill’s description. If it’s a match, the skill’s content effectively augments Claude’s context for that query.

Because Skills are model-invoked, it’s important to write clear descriptions and instructions in the SKILL.md so that the AI can accurately identify when to use them. Anthropic recommends keeping skills **focused and clearly scoped** (one skill per distinct capability), writing the description in natural language as if explaining to another developer what the skill covers[\[53\]](https://docs.claude.com/en/docs/claude-code/skills#:~:text=Agent%20Skills%20package%20expertise%20into,to%20trigger%20them%29.%20Benefits)[\[54\]](https://docs.claude.com/en/docs/claude-code/skills#:~:text=,complex%20tasks). Also, since skills are shareable via git, it’s good practice to version-control changes to SKILL.md and include notes on skill versions or updates (so teammates know how the skill might affect Claude’s behavior).

**Skills vs. Slash Commands:** Both mechanisms can be used to extend Claude, but they have different use cases. According to Anthropic’s guidance, use **slash commands** for quick, frequently repeated prompts or one-step actions you want to manually trigger (they’re like shortcuts). Use **Skills** for more comprehensive, multi-step or domain-specific assistance that you want Claude to handle proactively[\[36\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=Use%20slash%20commands%20for)[\[40\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=Use%20Skills%20for). In other words, if you have a complex workflow that involves multiple files or a suite of checks, and you’d like Claude to automatically apply that expertise whenever relevant, a Skill is ideal. Key differences include:

* **Invocation**: Slash commands require explicit user invocation (/my-command), whereas Skills are invoked implicitly by Claude when context cues match[\[55\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=Aspect%20Slash%20Commands%20Agent%20Skills,only%20Multiple%20files%2C%20scripts%2C%20templates).

* **Structure**: A slash command is a single Markdown file (one prompt), while a Skill is a *directory* of multiple files – allowing much richer content and even code/scripts[\[43\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=Aspect%20Slash%20Commands%20Agent%20Skills,Sharing%20Via%20git%20Via%20git).

* **Complexity**: Commands are best for simple or atomic tasks, whereas Skills can encode complex processes, decision trees, or large knowledge bases[\[56\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=Complexity%20Simple%20prompts%20Complex%20capabilities,Sharing%20Via%20git%20Via%20git).

* **Lifecycle**: Commands are often ad-hoc or personal, whereas Skills are meant to be shared and maintained by teams as part of the codebase (you might update a Skill as your processes evolve)[\[57\]](https://docs.claude.com/en/docs/claude-code/skills#:~:text=,multiple%20Skills%20for%20complex%20tasks)[\[58\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=Scope%20Project%20or%20personal%20Project,Sharing%20Via%20git%20Via%20git).

Both features can coexist and complement each other. For example, you might have a Skill that provides extensive domain knowledge (which Claude taps into automatically), and also have a slash command to explicitly trigger that skill’s function if you want. The choice comes down to whether you want manual control and simplicity (choose a slash command) or autonomous, context-aware behavior (define a skill). In practice, many advanced users start with slash commands and later refactor the more elaborate ones into Skills for scalability.

## Subagents: Parallelizing Tasks and Offloading Context

**Claude Code subagents** are one of the most powerful features for managing complex or long-running tasks. Each subagent is defined by a Markdown file (in .claude/agents/) with YAML frontmatter specifying its **name**, a short **description** of its purpose, the allowed **tools** it can use, and optionally a specific **model** to use[\[59\]](https://docs.claude.com/en/docs/claude-code/sub-agents#:~:text=Each%20subagent%20is%20defined%20in,Markdown%20file%20with%20this%20structure)[\[60\]](https://docs.claude.com/en/docs/claude-code/sub-agents#:~:text=Field%20Required%20Description%20,to%20the%20configured%20subagent%20model). The body of the file is a custom **system prompt** instructing how that subagent should operate (its role, strategy, and any constraints)[\[61\]](https://docs.claude.com/en/docs/claude-code/sub-agents#:~:text=Each%20subagent%20is%20defined%20in,Markdown%20file%20with%20this%20structure)[\[62\]](https://docs.claude.com/en/docs/claude-code/sub-agents#:~:text=Your%20subagent%27s%20system%20prompt%20goes,and%20approach%20to%20solving%20problems). When a subagent is invoked, Claude spins up a fresh context with that system prompt and only the content relevant to the subagent’s task. The subagent can then read files, run commands, or even call other tools (per its allowed tools) *independently* of the main conversation. Once it finishes, it hands results back to the main agent.

**Why use subagents?** They solve two big issues: **context limits and specialization**. Because each subagent has its own 100k token context (using Claude’s context window separately)[\[63\]](https://docs.claude.com/en/docs/claude-code/sub-agents#:~:text=tasks%20to), you can effectively get more total context by delegating. For example, if your main session is filling up with too much information, you can say, “Claude, use a subagent to deeply analyze module X,” and the subagent can load lots of data about module X without consuming the main session’s context budget[\[64\]](https://www.anthropic.com/engineering/claude-code-best-practices#:~:text=%28,to%20evaluate%20alternatives%20more%20thoroughly). This preserves the main agent’s focus for high-level objectives while the subagent deals with detailed analysis. Additionally, subagents can be configured with a **focused persona and toolset** – e.g. a “SQL Guru” agent that only has DB read access and a prompt to always double-check SQL logic. This yields higher accuracy on domain-specific tasks[\[7\]](https://docs.claude.com/en/docs/claude-code/sub-agents#:~:text=Specialized%20expertise). You can fine-tune each subagent’s prompt with best practices or knowledge for that domain, which the main agent might not always remember or have capacity for.

Common use cases for subagents include: **Code review agents**, which read diffs or modules and provide an independent review; **Test runner/fixer agents**, which run the test suite and automatically fix failing tests; **Research agents**, which can be instructed to search documentation or web (via tools) for answering a question; **Planner agents**, which given a feature request, only produce a detailed plan and checklist (without coding); etc. In fact, Anthropic’s internal workflows often encourage using a planning subagent early in a task to generate a thorough plan, thus preserving the main agent’s context for execution of that plan[\[64\]](https://www.anthropic.com/engineering/claude-code-best-practices#:~:text=%28,to%20evaluate%20alternatives%20more%20thoroughly).

**Creating subagents:** The easiest way is with the interactive /agents command. This opens a menu where you can **“Create New Agent”**, fill in its name, description, and select which tools it can use from a list[\[65\]](https://docs.claude.com/en/docs/claude-code/sub-agents#:~:text=,e)[\[66\]](https://docs.claude.com/en/docs/claude-code/sub-agents#:~:text=Using%20the%20%2Fagents%20command%20). You can also let Claude draft the initial agent prompt (it will generate a proposal you can edit)[\[67\]](https://docs.claude.com/en/docs/claude-code/sub-agents#:~:text=Define%20the%20subagent). Alternatively, you can hand-edit agent files in .claude/agents/. For example, to make a simple **test-runner** agent, create .claude/agents/test-runner.md with frontmatter:

\---  
name: test-runner  
description: Run test suite, diagnose failures, and fix them while preserving the original test intent.  
tools: Read, Edit, Write, Grep, Glob, Bash  
model: inherit  
\---

And in the body, instructions like: *“Run npm test. If any tests fail, identify the failure’s cause and minimally patch the code to fix it, without altering unrelated behavior. Re-run tests to verify.”* This agent is now available to be invoked. Project-level agents live in the repository (team-shared), while user-level agents in \~/.claude/agents/ apply to all your projects (but are lower priority if a project defines one with the same name)[\[68\]](https://docs.claude.com/en/docs/claude-code/sub-agents#:~:text=Project%20subagents,level%20subagents). You might keep a personal summarizer agent globally, for instance.

Claude will **automatically delegate** to subagents when it thinks the task fits one’s description. The description field is critical: if you phrase it as *“Use proactively to…”* or *“MUST be used when…”*, you can strongly cue Claude to spin up that agent at the right time[\[69\]](https://docs.claude.com/en/docs/claude-code/sub-agents#:~:text=Automatic%20delegation). For example, an agent with description “Use proactively after code changes to run tests and fix any failures” will often be picked up by Claude right after it makes code edits, without you even asking – it will say something like *“All tests passed. (Used the test-runner agent to verify.)”* This automatic delegation is one of subagents’ strengths: once defined, they can kick in whenever relevant, acting almost like parallel threads of thought for Claude. Of course, you can also explicitly request a subagent: e.g. *“Use the security-reviewer subagent to audit the last commit for security issues.”* Mentioning the agent by name in your prompt will trigger Claude to hand the task to it[\[70\]](https://docs.claude.com/en/docs/claude-code/sub-agents#:~:text=Save%20and%20use)[\[71\]](https://docs.claude.com/en/docs/claude-code/sub-agents#:~:text=Using%20the%20%2Fagents%20command%20).

**Example – multi-agent workflow:** Suppose you have three subagents defined: a **planner** (laravel-planner), a **coder** (laravel-coder), and a **test runner** (test-runner), each tailored to a Laravel project. A typical workflow might go like this:

1. **Planning:** *“Use the laravel-planner subagent to plan an ‘Invoices’ feature with API endpoints, PDF generation, etc., and save the plan to docs/plan.md.”* – The planner agent (with only read/search tools) analyzes the request and produces a detailed design and task list in docs/plan.md (as instructed in its prompt)[\[72\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=Use%20the%20laravel,list%20exact%20commands%20to%20run). The main agent remains unaffected by the large analysis because it all happened in the sub context. You review the plan.md file that the subagent created.

2. **Implementation:** *“Great, now use the laravel-coder subagent to implement docs/plan.md. Follow the plan’s steps, generate code with small commits, and when done, open a PR.”* – The coder agent (with write/edit and artisan tool permissions) will read the plan from file and execute it step by step[\[73\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=After%20you%20approve%20the%20plan%3A). It might create models, controllers, run Artisan generators, etc., as laid out. It keeps diffs small and commits as directed (its prompt and your instructions enforce this). Finally, it pushes a commit or PR with message “feat: invoices module”[\[73\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=After%20you%20approve%20the%20plan%3A). The entire coding happened in the subagent’s world, so the main agent’s context wasn’t overloaded with code diffs – the main just sees the high-level outcome.

3. **Testing & Review:** *“Use the test-runner subagent to run the tests and fix any failures.”* – Now the test-runner agent (with bash and edit rights) runs php artisan test. Suppose some tests fail; it isolates the issues and patches the code accordingly, then reports success[\[74\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=Test%20%26%20fix). Meanwhile, you could also explicitly invoke a security-reviewer subagent: *“Use the security-reviewer agent to audit the new code for security vulnerabilities.”* That agent (read-only) would comb through the changes focusing on auth, input validation, etc., and return a report.

In this way, subagents enable a **sequential orchestration of tasks** that feels like parallelization. Each agent handles its stage with expertise, and the handoff is often done via files (the plan markdown, test results, etc.) – a robust way to pass state without clogging conversation context. Indeed, a common pattern is having one agent produce an artifact (like a plan file or a summary) that another agent later consumes; this *agent handover via markdown files* keeps the workflow organized and auditable. For example, writing a design to PLAN.md or summary to REPORT.md can act as a contract between agents.

*Figure: Output from a custom slash command that launched multiple specialized TypeScript subagents to analyze compilation errors in parallel. Each subagent (e.g. typescript-api-analyzer, typescript-frontend-analyzer, etc.) ran concurrently on different parts of the codebase. The tool output shows “Done with 8 parallel agents” for each, indicating how tasks were split for maximum efficiency.*

It’s important to note that within a single Claude Code session (REPL), subagent execution is still cooperative multi-tasking – the main agent delegates and waits for each subagent to finish turn by turn. So you don’t get true simultaneous threads in one session (the **parallelism is logical**, as the figure above shows multiple subagents being used in succession for different segments)[\[75\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=In%20a%20single%20Claude%20Code,%E2%80%9CSubagent%20Stop%E2%80%9D%20hooks%20are%20described). If you truly need concurrency (say running tests *while* generating code), you’d currently have to run two Claude sessions in parallel (e.g. using Git worktrees or separate terminals)[\[75\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=In%20a%20single%20Claude%20Code,%E2%80%9CSubagent%20Stop%E2%80%9D%20hooks%20are%20described). That said, subagents *do* allow Claude to tackle parts of a problem independently, often leading to faster overall completion since each subagent can focus and then exit, freeing the context for the next. And as the above example demonstrates, you can design a single slash command or workflow that spawns many subagents to effectively distribute work across a large task (the user on Reddit created 49 subagents to check TypeScript errors in different packages simultaneously\!)[\[76\]](https://www.reddit.com/r/ClaudeAI/comments/1m8u4cx/wonderful_world_of_claude_code_subagents_running/#:~:text=Claude%20Code%20custom%20slash%20command,pushing%20ccusage%20reported%20887K%20tokens%2Fmin).

Managing subagents is made easy with /agents. You can list all active subagents, edit or delete them, and see which are currently loaded. Subagents can also come from **plugins** – some Claude Code plugins bundle their own agents for specialized functions (these show up in the same interface, often with namespacing)[\[77\]](https://docs.claude.com/en/docs/claude-code/sub-agents#:~:text=Plugin%20agents). Each subagent can use any subset of Claude’s tools; by limiting tools you not only sandbox what it can do for security[\[78\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=,end%E2%80%91to%E2%80%91end%2C%20and%20composing%20workfows%20%E2%80%94), but also help it focus (e.g. a planning agent might not need write access, reducing the chance it tries to “do” instead of plan). For advanced control, you can even define subagents on the fly with the CLI (passing a JSON config via claude \--agents '\<json\>') for quick one-off sessions or scripting use cases[\[79\]](https://docs.claude.com/en/docs/claude-code/sub-agents#:~:text=You%20can%20also%20define%20subagents,which%20accepts%20a%20JSON%20object)[\[80\]](https://docs.claude.com/en/docs/claude-code/sub-agents#:~:text=Priority%3A%20CLI,This%20approach%20is%20useful%20for).

**Best practices for subagents:** Treat them as you would microservices in software design. Give each a single clear responsibility and **strong prompt guidance** on how to perform that role. Use the description to clearly indicate triggers (including words like “after X, use this” or “for Y task”) so Claude knows when to delegate[\[69\]](https://docs.claude.com/en/docs/claude-code/sub-agents#:~:text=Automatic%20delegation). You can chain subagents by simply instructing Claude in plain English: “First, use the X subagent to do A, then use the Y subagent to do B” – Claude will carry out the sequence in order[\[81\]](https://docs.claude.com/en/docs/claude-code/sub-agents#:~:text=Chaining%20subagents). Remember that while subagents preserve main context, they do incur some overhead: each one starts with an empty context (except its system prompt), so it may need to load up relevant files or re-read some info which takes extra tokens and time[\[82\]](https://docs.claude.com/en/docs/claude-code/sub-agents#:~:text=,to%20do%20their%20job%20effectively). However, the trade-off is usually worth it for complex tasks, as the main agent’s 100k context is not eaten up by all those details. Also consider version controlling your important project subagents (they’re just markdown files, after all) so that improvements to their prompts or fixes to their configuration are tracked and shared[\[83\]](https://docs.claude.com/en/docs/claude-code/sub-agents#:~:text=purpose,from%20and%20improve%20them%20collaboratively).

## Composing Workflows with Commands, Subagents, and Skills

The true power of Claude Code emerges when you combine these features to create **orchestrated workflows**. A “workflow” in this context might be a complex developer task (like “Implement a new feature end-to-end” or “Perform a full security audit”) that can be broken into stages and handled by different capabilities of Claude. Here are some tips and examples on composition:

* **Use Slash Commands as High-Level Orchestration Units:** A slash command can act as the entry point to a workflow, coordinating multiple steps. For example, you might write a /full-stack-feature command to *“Implement a full-stack feature across backend, frontend, and mobile”*. Inside that command’s markdown, you could instruct Claude to break the task down and possibly invoke specific subagents for each layer. An actual community example is the feature-development workflow command, which orchestrates an OAuth2 authentication feature by coordinating backend and frontend changes, effectively leveraging multiple agent capabilities in one go[\[84\]\[85\]](https://github.com/wshobson/commands#:~:text=). By encapsulating the overall process in a slash command, you ensure the sequence is followed consistently every time, with all necessary steps.

* **Let Subagents Handle Parallel Subtasks or Noisy Processes:** Within a slash command or your manual instructions, you can explicitly tell Claude to *“spawn subagents”* for parts of the work. For instance, your workflow command for feature implementation could include steps like: “Use the database-migrator agent to apply DB schema changes” and “use the UI-designer agent to suggest UI modifications in parallel.” Claude can execute these subagents one after the other, which for you feels like it tackled them in parallel without overloading one context. In practice, a complex slash command can trigger a flurry of subagent actions (as shown earlier with the TypeScript check example), each subagent focusing on one aspect. This modularizes the workflow – if one subagent fails or produces output, the main agent (or command script) can handle that, then move on to the next. **Subagents essentially allow workflow branching without confusion**, since each branch’s details stay in its own channel.

* **Incorporate Skills for Domain Knowledge:** If your workflow touches on specialized domains (security, UX, data science, etc.), consider creating Agent Skills that provide background knowledge or checklists for those domains, and let Claude automatically apply them during the workflow. For example, a “SecurityAudit” skill could contain OWASP top-10 guidelines and code patterns to avoid. When your workflow (via either direct prompt or a slash command) asks Claude to perform a security review, Claude might automatically pull in the SecurityAudit skill content to enhance its review. Unlike subagents, Skills don’t require you to spawn anything – they’re more like passive enhancers that Claude will use if available. So, **compose workflows such that general requests can trigger relevant skills**. A workflow command might simply say “review the code for performance and security issues” – behind the scenes, Claude may invoke both the Performance Tuning skill and Security Audit skill to produce a thorough answer, without you explicitly coding those steps.

* **Sequence and Handover:** Design your multi-step processes with clear handover points, often using files as interfaces between steps. This is a robust pattern as seen in the Laravel example above: the Plan \-\> Code \-\> Test sequence was glued by a plan.md file and the codebase itself. Another scenario: a bug-fix workflow could be, “1) Use an agent to reproduce the bug and log the error to error.log. 2\) Use a second agent to analyze error.log and locate root cause. 3\) Use a third step (main agent or subagent) to apply the fix and verify.” By writing each result to a file (or even just relying on version control diff as the state), you ensure continuity without keeping everything in one huge context. **Markdown files, git commits, and issue trackers can all serve as mediums for agent handover**. Claude Code is comfortable reading from and writing to files, so leverage that: e.g., ask one agent to output a summary report to REPORT.md and later have another read from REPORT.md – this mimics how one human specialist might hand a document to another.

* **Parallel Session Workflows:** If you need true concurrency (for example, running a long database migration in one thread while another agent monitors something else), you can spin up multiple Claude Code sessions. A practical approach is using Git worktrees or branches – for instance, run Claude Code on branch “feature-X” and another on “feature-X-tests” simultaneously to have two agents working. They won’t share live context (they are separate processes), but you can merge their outputs via git. Some advanced community workflows use CI pipelines that launch Claude with different tasks in parallel (e.g., one job runs /security-scan command, another runs /performance-optimize on the same codebase) and then combine results. Keep in mind synchronization issues – you may want one to wait for the other’s output. In general, though, **most use cases won’t require true parallel threads**; using subagents sequentially often suffices, as Claude is quite fast at jumping between tasks.

To illustrate a complex orchestrated workflow, consider a **“Legacy System Modernization”** command that was part of a community collection[\[86\]](https://github.com/wshobson/commands#:~:text=Command%20Composition%20Strategies). Such a workflow might: check out a legacy codebase, spawn analysis subagents (architecture reviewer, dependency auditor), collect their findings, then spawn refactoring subagents (for database, for API layer, etc.), each possibly using different Skills (e.g., a “Refactoring Patterns” skill) to guide them, and finally open a pull request with all the changes. All of this can be kicked off with one slash command and a series of well-coordinated instructions and agent handovers. The command basically becomes a **script for multi-agent collaboration**.

In summary, **slash commands** are your way to package and trigger multi-step workflows, **subagents** are your means to divide-and-conquer tasks and preserve focus, and **skills** are your passive boosters that enrich Claude’s abilities in specific areas. By mixing these, you can automate extremely sophisticated development tasks. It’s helpful to start by mapping out the workflow steps on paper, deciding which steps need isolation (subagent), which steps are repetitive (make them a slash command or skill), and what context or knowledge is needed at each step (prepare memory or skills accordingly). This is essentially **prompt engineering at the workflow level**.

## Prompt and Context Engineering Best Practices for Claude Code

Finally, to ensure you get the best results, it’s worth following some **prompt engineering and context management best practices** tailored for Claude Code:

* **Follow a Plan → Act → Review cycle:** Don’t rush Claude straight into writing code. It excels when given a chance to *think first*. A proven strategy is to first prompt Claude to **analyze or plan** (possibly in Plan Mode, which restricts it to read-only actions)[\[87\]](https://docs.claude.com/en/docs/claude-code/common-workflows#:~:text=Use%20Plan%20Mode%20for%20safe,code%20analysis), then proceed to coding, and finally have it review or test its work[\[88\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=,AnthropicAnthropic). You can literally prompt: “First, think step-by-step and make a plan (do not write code yet).” Using phrases like *“think harder”* or *“ultrathink”* in your prompt triggers Claude’s extended reasoning time[\[41\]](https://www.anthropic.com/engineering/claude-code-best-practices#:~:text=early%20on%20in%20a%20conversation,reset%20to%20this%20spot%20if). For example: *“Please* *think hard* *and draft a step-by-step approach to implement this feature.”* – This gives you a plan to approve (and you can even ask Claude to save the plan to a file for record). After execution, use another prompt or agent to review (e.g. *“Now review the changes and ensure everything aligns with the plan”*). This approach mirrors Test-Driven Development or the Anthropican “plan first” workflow and tends to produce higher quality outcomes[\[89\]](https://www.anthropic.com/engineering/claude-code-best-practices#:~:text=Steps%20%231,problems%20requiring%20deeper%20thinking%20upfront)[\[90\]](https://www.anthropic.com/engineering/claude-code-best-practices#:~:text=Claude%20performs%20best%20when%20it,incrementally%20improve%20until%20it%20succeeds).

* **Be specific and directive in prompts:** Vague prompts yield vague results. Claude responds much better to concrete instructions and success criteria. When asking for code or changes, specify details like *“avoid modifying function X,”* or *“use a 2-space indent and include type hints”*, or *“output only the JSON result, no extra commentary”*. In Anthropic’s words, *“Claude’s success rate improves significantly with more specific instructions, especially on first attempts”*[\[91\]](https://www.anthropic.com/engineering/claude-code-best-practices#:~:text=a,instructions). If you want Claude to follow certain steps or verify something, **explicitly say so** (or encode it in a slash command). For instance, instead of *“fix this bug”*, say *“identify the root cause of the null pointer exception in UserService, then fix it by adding a null check as per our style guide, and explain what you changed.”* If you have a template for outputs (say, a certain format for release notes or test reports), provide that in the prompt or memory so Claude can mimic it. Essentially, **over-communicate your expectations** – Claude won’t take offense\! It actually performs best when given clear guidance on format, style, and process[\[92\]](https://www.anthropic.com/engineering/claude-code-best-practices#:~:text=For%20example%3A).

* **Leverage context wisely:** Use the tools we discussed to keep the relevant context at hand. Put stable guidelines in CLAUDE.md rather than repeating them. Use the @file includes to feed in large context like specs or logs when needed (e.g., “Refer to @error.log for the stack trace”). If a conversation drifts or becomes cluttered, you can use /compact to summarize and reclaim context, or /rewind to remove some turns[\[93\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=,md%20guide)[\[94\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=,iTerm2%20and). Another trick: if Claude has analyzed something lengthy and you won’t need that detail again, you can instruct it to *“forget the details above and just remember the conclusion XYZ”* – or simply move on, trusting that it has the conclusion internally. Also, as mentioned, call on subagents for heavy lifting in separate context. This way, your main conversation can remain relatively clean and focused, which improves coherence.

* **Iterate and refine prompts:** Treat prompt engineering as an interactive process. If Claude’s output isn’t what you want, don’t hesitate to clarify or correct it. You might say: *“The solution you gave is not using the recommended library – please redo it using XYZ library as per our guidelines (see memory).”* Claude Code is stateful within a session, so it will take that feedback and adjust. If it still struggles, try a different angle or break the task down. Sometimes introducing a brief **role-play or scenario** in your prompt helps (“Imagine you are a linter, find all style issues…” or “You are a senior architect, propose a design…”). The Output styles feature and directives can be used too if you want answers in a certain tone or format[\[95\]](https://docs.claude.com/en/docs/claude-code/skills#:~:text=On%20this%20page), though in coding scenarios it’s usually about structuring the answer (e.g., “provide a Markdown table of differences” or “give the response as a JSON snippet”).

* **Use Hooks and Permissions for safety and consistency:** Claude Code allows you to set up **hooks** (automated triggers) and customize tool permissions – these aren’t prompts per se, but they influence how Claude operates. For example, you can add a *pre-edit hook* that prevents certain files from being modified (Claude will then refuse to edit those, protecting critical config)[\[96\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=Create%20a%20file%E2%80%91protection%20hook%20to,env). Or you could enforce that every time a subagent finishes, a summary is appended to a log. These measures can indirectly prompt Claude to behave consistently without your manual intervention each time. If you have a particular sequence you always do (like run npm run lint after every edit), you could automate that with a hook so Claude executes it (and fixes issues) automatically – effectively a persistent hidden prompt.

* **Keep human oversight in the loop:** Despite all the autonomy, it’s best to supervise key decision points. For instance, when Claude (or a subagent) produces a plan or major change set, take a moment to review the plan yourself before saying “proceed” or having another agent act on it. You might catch misinterpretations early. This aligns with Anthropic’s own best practices of *keeping changes gated by approvals and tool permissions*[\[88\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=,AnthropicAnthropic). A good prompt to remember is “Before we continue, summarize the plan/changes and ask for confirmation.” – you can train yourself to incorporate this, or encode it in your slash commands (like the /fix-github-issue example could have a step 9: “Ask user for approval before opening PR”). Claude is an assistant, not infallible; a bit of **prompted verification** (e.g., “Double-check that you didn’t break any existing API – list any assumptions you made”) can save time in the long run.

* **Exploit Claude’s strengths**: Claude is particularly good at understanding high-level intent, writing coherent natural language, and refactoring or transforming code systematically. So make use of that – for documentation tasks, ask it to “explain in simple terms,” for design tasks ask it to enumerate pros/cons. It also can keep track of a lot of context – feel free to feed it multiple files at once (via multiple @file references or by selecting several files in VS Code plugin) and ask it to find connections. In large codebases, you can prompt it to *“glob search for X pattern and summarize findings”* leveraging its built-in Glob and Grep tools. Basically, **treat it as a capable junior developer with a phenomenal memory and fast typing speed** – it can do grunt work (like renaming a variable across dozens of files or running all tests and collating results) with ease, as long as you clearly ask.

By adhering to these practices, you’ll make the most of Claude Code’s agentic features. It’s a very powerful system – almost like having an AI pair-programming partner who can also spin up additional “assistants” (subagents) and reference an entire library of knowledge (skills and memories) on demand. With well-engineered prompts, structured context, and smart division of tasks, you can tackle large-scale development or analysis tasks that would be daunting to do manually. Happy coding with Claude\!

**Sources:** The information above is synthesized from Anthropic’s official Claude Code documentation and user-contributed guides, including the Claude Docs on slash commands, subagents, skills, and memory[\[14\]](https://docs.claude.com/en/docs/claude-code/memory#:~:text=CLAUDE,following%20example%20imports%203%20files)[\[97\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=Key%20differences)[\[98\]](https://docs.claude.com/en/docs/claude-code/sub-agents#:~:text=What%20are%20subagents%3F), as well as community examples and best practices from Anthropic’s engineering blog and experienced users[\[64\]](https://www.anthropic.com/engineering/claude-code-best-practices#:~:text=%28,to%20evaluate%20alternatives%20more%20thoroughly)[\[74\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=Test%20%26%20fix). These sources provide deeper dives and additional examples for those interested in extending Claude Code’s capabilities even further.

---

[\[1\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=,let%20you%20scale%20reliable%2C%20repeatable) [\[3\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=chat.%20,let%20you%20scale%20reliable%2C%20repeatable) [\[6\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=prompt%2C%20tool%20permissions%2C%20and%20an,you%20scale%20reliable%2C%20repeatable%20workflows) [\[20\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=,as%20of%20June%2018%2C%202025) [\[21\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=2,your%20standards) [\[72\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=Use%20the%20laravel,list%20exact%20commands%20to%20run) [\[73\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=After%20you%20approve%20the%20plan%3A) [\[74\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=Test%20%26%20fix) [\[75\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=In%20a%20single%20Claude%20Code,%E2%80%9CSubagent%20Stop%E2%80%9D%20hooks%20are%20described) [\[78\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=,end%E2%80%91to%E2%80%91end%2C%20and%20composing%20workfows%20%E2%80%94) [\[88\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=,AnthropicAnthropic) [\[96\]](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00#:~:text=Create%20a%20file%E2%80%91protection%20hook%20to,env) Practical guide to mastering Claude Code’s main agent and Sub‑agents | by Md Mazaharul Huq | Jul, 2025 | Medium

[https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00](https://jewelhuq.medium.com/practical-guide-to-mastering-claude-codes-main-agent-and-sub-agents-fd52952dcf00)

[\[2\]](https://docs.claude.com/en/docs/claude-code/overview#:~:text=will%20analyze%20your%20codebase%2C%20identify,Google%20Drive%2C%20Figma%2C%20and%20Slack) [\[9\]](https://docs.claude.com/en/docs/claude-code/overview#:~:text=commits,in) Claude Code overview \- Claude Docs

[https://docs.claude.com/en/docs/claude-code/overview](https://docs.claude.com/en/docs/claude-code/overview)

[\[4\]](https://docs.claude.com/en/docs/claude-code/sub-agents#:~:text=Subagents%20are%20pre,Each%20subagent) [\[5\]](https://docs.claude.com/en/docs/claude-code/sub-agents#:~:text=Each%20subagent%20operates%20in%20its,level%20objectives) [\[7\]](https://docs.claude.com/en/docs/claude-code/sub-agents#:~:text=Specialized%20expertise) [\[8\]](https://docs.claude.com/en/docs/claude-code/sub-agents#:~:text=Reusability) [\[59\]](https://docs.claude.com/en/docs/claude-code/sub-agents#:~:text=Each%20subagent%20is%20defined%20in,Markdown%20file%20with%20this%20structure) [\[60\]](https://docs.claude.com/en/docs/claude-code/sub-agents#:~:text=Field%20Required%20Description%20,to%20the%20configured%20subagent%20model) [\[61\]](https://docs.claude.com/en/docs/claude-code/sub-agents#:~:text=Each%20subagent%20is%20defined%20in,Markdown%20file%20with%20this%20structure) [\[62\]](https://docs.claude.com/en/docs/claude-code/sub-agents#:~:text=Your%20subagent%27s%20system%20prompt%20goes,and%20approach%20to%20solving%20problems) [\[63\]](https://docs.claude.com/en/docs/claude-code/sub-agents#:~:text=tasks%20to) [\[65\]](https://docs.claude.com/en/docs/claude-code/sub-agents#:~:text=,e) [\[66\]](https://docs.claude.com/en/docs/claude-code/sub-agents#:~:text=Using%20the%20%2Fagents%20command%20) [\[67\]](https://docs.claude.com/en/docs/claude-code/sub-agents#:~:text=Define%20the%20subagent) [\[68\]](https://docs.claude.com/en/docs/claude-code/sub-agents#:~:text=Project%20subagents,level%20subagents) [\[69\]](https://docs.claude.com/en/docs/claude-code/sub-agents#:~:text=Automatic%20delegation) [\[70\]](https://docs.claude.com/en/docs/claude-code/sub-agents#:~:text=Save%20and%20use) [\[71\]](https://docs.claude.com/en/docs/claude-code/sub-agents#:~:text=Using%20the%20%2Fagents%20command%20) [\[77\]](https://docs.claude.com/en/docs/claude-code/sub-agents#:~:text=Plugin%20agents) [\[79\]](https://docs.claude.com/en/docs/claude-code/sub-agents#:~:text=You%20can%20also%20define%20subagents,which%20accepts%20a%20JSON%20object) [\[80\]](https://docs.claude.com/en/docs/claude-code/sub-agents#:~:text=Priority%3A%20CLI,This%20approach%20is%20useful%20for) [\[81\]](https://docs.claude.com/en/docs/claude-code/sub-agents#:~:text=Chaining%20subagents) [\[82\]](https://docs.claude.com/en/docs/claude-code/sub-agents#:~:text=,to%20do%20their%20job%20effectively) [\[83\]](https://docs.claude.com/en/docs/claude-code/sub-agents#:~:text=purpose,from%20and%20improve%20them%20collaboratively) [\[98\]](https://docs.claude.com/en/docs/claude-code/sub-agents#:~:text=What%20are%20subagents%3F) Subagents \- Claude Docs

[https://docs.claude.com/en/docs/claude-code/sub-agents](https://docs.claude.com/en/docs/claude-code/sub-agents)

[\[10\]](https://docs.claude.com/en/docs/claude-code/memory#:~:text=members%20via%20source%20control%20User,more%20specific%20memories%20build%20upon) [\[11\]](https://docs.claude.com/en/docs/claude-code/memory#:~:text=Linux%3A%20%60%2Fetc%2Fclaude,all%20projects) [\[12\]](https://docs.claude.com/en/docs/claude-code/memory#:~:text=%2A%20Be%20specific%3A%20%E2%80%9CUse%202,to%20date%20information%20and%20context) [\[13\]](https://docs.claude.com/en/docs/claude-code/memory#:~:text=,to%20date%20information%20and%20context) [\[14\]](https://docs.claude.com/en/docs/claude-code/memory#:~:text=CLAUDE,following%20example%20imports%203%20files) [\[15\]](https://docs.claude.com/en/docs/claude-code/memory#:~:text=See%20%40README%20for%20project%20overview,npm%20commands%20for%20this%20project) [\[16\]](https://docs.claude.com/en/docs/claude-code/memory#:~:text=Copy) [\[17\]](https://docs.claude.com/en/docs/claude-code/memory#:~:text=Quickly%20add%20memories%20with%20the,shortcut) [\[22\]](https://docs.claude.com/en/docs/claude-code/memory#:~:text=How%20Claude%20looks%20up%20memories) Manage Claude's memory \- Claude Docs

[https://docs.claude.com/en/docs/claude-code/memory](https://docs.claude.com/en/docs/claude-code/memory)

[\[18\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=,for%20safer%2C%20more%20autonomous%20execution) [\[23\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=Command%20Purpose%20%60%2Fadd,specific%20details) [\[27\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=Pass%20dynamic%20values%20to%20commands,using%20argument%20placeholders) [\[28\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=,etc) [\[29\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=Namespacing) [\[30\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=Project%20commands) [\[31\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=Personal%20commands) [\[32\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=,slash%20commands%20that) [\[33\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=Disable%20) [\[34\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=Disable%20specific%20commands%20only) [\[35\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=The%20,command%E2%80%99s%20name%2C%20args%2C%20and%20description) [\[36\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=Use%20slash%20commands%20for) [\[37\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=,this%20code%20for%20performance%20issues%E2%80%9D) [\[38\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=Quick%2C%20frequently) [\[39\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=Use%20Skills%20for) [\[40\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=Use%20Skills%20for) [\[43\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=Aspect%20Slash%20Commands%20Agent%20Skills,Sharing%20Via%20git%20Via%20git) [\[46\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=,with%20style%20guides%20and%20templates) [\[47\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=Example%20comparison) [\[48\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=.claude%2Fskills%2Fcode,linters.sh) [\[49\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=Usage%3A%20,a%20Skill) [\[50\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=Usage%3A%20%E2%80%9CCan%20you%20review%20this,scripts%2C%20and%20organized%20reference%20material) [\[55\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=Aspect%20Slash%20Commands%20Agent%20Skills,only%20Multiple%20files%2C%20scripts%2C%20templates) [\[56\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=Complexity%20Simple%20prompts%20Complex%20capabilities,Sharing%20Via%20git%20Via%20git) [\[58\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=Scope%20Project%20or%20personal%20Project,Sharing%20Via%20git%20Via%20git) [\[93\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=,md%20guide) [\[94\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=,iTerm2%20and) [\[97\]](https://docs.claude.com/en/docs/claude-code/slash-commands#:~:text=Key%20differences) Slash commands \- Claude Docs

[https://docs.claude.com/en/docs/claude-code/slash-commands](https://docs.claude.com/en/docs/claude-code/slash-commands)

[\[19\]](https://github.com/centminmod/my-claude-code-setup#:~:text=3,YouTube%20guides%20here%20and%20here) GitHub \- centminmod/my-claude-code-setup: Shared starter template configuration and CLAUDE.md memory bank system for Claude Code

[https://github.com/centminmod/my-claude-code-setup](https://github.com/centminmod/my-claude-code-setup)

[\[24\]](https://www.anthropic.com/engineering/claude-code-best-practices#:~:text=c) [\[25\]](https://www.anthropic.com/engineering/claude-code-best-practices#:~:text=For%20example%2C%20here%E2%80%99s%20a%20slash,and%20fix%20a%20Github%20issue) [\[26\]](https://www.anthropic.com/engineering/claude-code-best-practices#:~:text=Copy) [\[41\]](https://www.anthropic.com/engineering/claude-code-best-practices#:~:text=early%20on%20in%20a%20conversation,reset%20to%20this%20spot%20if) [\[64\]](https://www.anthropic.com/engineering/claude-code-best-practices#:~:text=%28,to%20evaluate%20alternatives%20more%20thoroughly) [\[89\]](https://www.anthropic.com/engineering/claude-code-best-practices#:~:text=Steps%20%231,problems%20requiring%20deeper%20thinking%20upfront) [\[90\]](https://www.anthropic.com/engineering/claude-code-best-practices#:~:text=Claude%20performs%20best%20when%20it,incrementally%20improve%20until%20it%20succeeds) [\[91\]](https://www.anthropic.com/engineering/claude-code-best-practices#:~:text=a,instructions) [\[92\]](https://www.anthropic.com/engineering/claude-code-best-practices#:~:text=For%20example%3A) Claude Code Best Practices \\ Anthropic

[https://www.anthropic.com/engineering/claude-code-best-practices](https://www.anthropic.com/engineering/claude-code-best-practices)

[\[42\]](https://docs.claude.com/en/docs/claude-code/skills#:~:text=Agent%20Skills%20package%20expertise%20into,to%20trigger%20them%29.%20Benefits) [\[44\]](https://docs.claude.com/en/docs/claude-code/skills#:~:text=consists%20of%20a%20,to%20trigger%20them%29.%20Benefits) [\[45\]](https://docs.claude.com/en/docs/claude-code/skills#:~:text=invoked%3A%20Skills%20are%20model,to%20trigger%20them%29.%20Benefits) [\[51\]](https://docs.claude.com/en/docs/claude-code/skills#:~:text=Personal%20Skills) [\[52\]](https://docs.claude.com/en/docs/claude-code/skills#:~:text=Project%20Skills) [\[53\]](https://docs.claude.com/en/docs/claude-code/skills#:~:text=Agent%20Skills%20package%20expertise%20into,to%20trigger%20them%29.%20Benefits) [\[54\]](https://docs.claude.com/en/docs/claude-code/skills#:~:text=,complex%20tasks) [\[57\]](https://docs.claude.com/en/docs/claude-code/skills#:~:text=,multiple%20Skills%20for%20complex%20tasks) [\[95\]](https://docs.claude.com/en/docs/claude-code/skills#:~:text=On%20this%20page) Agent Skills \- Claude Docs

[https://docs.claude.com/en/docs/claude-code/skills](https://docs.claude.com/en/docs/claude-code/skills)

[\[76\]](https://www.reddit.com/r/ClaudeAI/comments/1m8u4cx/wonderful_world_of_claude_code_subagents_running/#:~:text=Claude%20Code%20custom%20slash%20command,pushing%20ccusage%20reported%20887K%20tokens%2Fmin) Wonderful world of Claude Code subagents running for \~2.5hrs non-stop\! : r/ClaudeAI

[https://www.reddit.com/r/ClaudeAI/comments/1m8u4cx/wonderful\_world\_of\_claude\_code\_subagents\_running/](https://www.reddit.com/r/ClaudeAI/comments/1m8u4cx/wonderful_world_of_claude_code_subagents_running/)

[\[84\]](https://github.com/wshobson/commands#:~:text=) [\[85\]](https://github.com/wshobson/commands#:~:text=) [\[86\]](https://github.com/wshobson/commands#:~:text=Command%20Composition%20Strategies) GitHub \- wshobson/commands: A collection of production-ready slash commands for Claude Code

[https://github.com/wshobson/commands](https://github.com/wshobson/commands)

[\[87\]](https://docs.claude.com/en/docs/claude-code/common-workflows#:~:text=Use%20Plan%20Mode%20for%20safe,code%20analysis) Common workflows \- Claude Docs

[https://docs.claude.com/en/docs/claude-code/common-workflows](https://docs.claude.com/en/docs/claude-code/common-workflows)